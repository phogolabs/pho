// This file was generated by counterfeiter
package fakes

import (
	"sync"

	"github.com/svett/pho"
)

type FakeResponseWriter struct {
	WriteStub        func(string, int, []byte) error
	writeMutex       sync.RWMutex
	writeArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 []byte
	}
	writeReturns struct {
		result1 error
	}
	WriteErrorStub        func(err error, code int) error
	writeErrorMutex       sync.RWMutex
	writeErrorArgsForCall []struct {
		err  error
		code int
	}
	writeErrorReturns struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeResponseWriter) Write(arg1 string, arg2 int, arg3 []byte) error {
	var arg3Copy []byte
	if arg3 != nil {
		arg3Copy = make([]byte, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.writeMutex.Lock()
	fake.writeArgsForCall = append(fake.writeArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 []byte
	}{arg1, arg2, arg3Copy})
	fake.recordInvocation("Write", []interface{}{arg1, arg2, arg3Copy})
	fake.writeMutex.Unlock()
	if fake.WriteStub != nil {
		return fake.WriteStub(arg1, arg2, arg3)
	}
	return fake.writeReturns.result1
}

func (fake *FakeResponseWriter) WriteCallCount() int {
	fake.writeMutex.RLock()
	defer fake.writeMutex.RUnlock()
	return len(fake.writeArgsForCall)
}

func (fake *FakeResponseWriter) WriteArgsForCall(i int) (string, int, []byte) {
	fake.writeMutex.RLock()
	defer fake.writeMutex.RUnlock()
	return fake.writeArgsForCall[i].arg1, fake.writeArgsForCall[i].arg2, fake.writeArgsForCall[i].arg3
}

func (fake *FakeResponseWriter) WriteReturns(result1 error) {
	fake.WriteStub = nil
	fake.writeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeResponseWriter) WriteError(err error, code int) error {
	fake.writeErrorMutex.Lock()
	fake.writeErrorArgsForCall = append(fake.writeErrorArgsForCall, struct {
		err  error
		code int
	}{err, code})
	fake.recordInvocation("WriteError", []interface{}{err, code})
	fake.writeErrorMutex.Unlock()
	if fake.WriteErrorStub != nil {
		return fake.WriteErrorStub(err, code)
	}
	return fake.writeErrorReturns.result1
}

func (fake *FakeResponseWriter) WriteErrorCallCount() int {
	fake.writeErrorMutex.RLock()
	defer fake.writeErrorMutex.RUnlock()
	return len(fake.writeErrorArgsForCall)
}

func (fake *FakeResponseWriter) WriteErrorArgsForCall(i int) (error, int) {
	fake.writeErrorMutex.RLock()
	defer fake.writeErrorMutex.RUnlock()
	return fake.writeErrorArgsForCall[i].err, fake.writeErrorArgsForCall[i].code
}

func (fake *FakeResponseWriter) WriteErrorReturns(result1 error) {
	fake.WriteErrorStub = nil
	fake.writeErrorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeResponseWriter) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.writeMutex.RLock()
	defer fake.writeMutex.RUnlock()
	fake.writeErrorMutex.RLock()
	defer fake.writeErrorMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeResponseWriter) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ pho.ResponseWriter = new(FakeResponseWriter)
